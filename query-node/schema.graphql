# temporary type used before `DateTime` type is working
type DateTime @entity {
  timestamp: BigInt!
}

enum Network {
  BABYLON
  ALEXANDRIA
  ROME
}

type Block @entity {
  "Block number as a string"
  id: ID!
  block: Int!
  executedAt: DateTime!
  network: Network!
}

enum MembershipEntryMethod {
  PAID
  SCREENING
  GENESIS
}

"Stored information about a registered user"
type Membership @entity {
  "MemberId: runtime identifier for a user"
  id: ID!

  "The unique handle chosen by member"
  handle: String! @unique @fulltext(query: "membersByHandle")

  "A Url to member's Avatar image"
  avatarUri: String

  "Short text chosen by member to share information about themselves"
  about: String

  "Member's controller account id"
  controllerAccount: String!

  "Member's root account id"
  rootAccount: String!

  "Blocknumber when member was registered"
  registeredAtBlock: Block!

  "Timestamp when member was registered"
  registeredAtTime: DateTime!

  "How the member was registered"
  entry: MembershipEntryMethod!

  "The type of subscription the member has purchased if any."
  subscription: BigInt
}

"Category of media channel"
type ChannelCategory @entity {
  id: ID!

  "The name of the category"
  name: String @fulltext(query: "channelCategoriesByName")

  channels: [Channel!] @derivedFrom(field: "category")

  happenedIn: Block!
}

"Asset availability representation"
enum AssetAvailability {
  ACCEPTED, # asset is available in storage
  PENDING, # asset is being uploaded to storage
  URL, # asset is referencing URL
  INVALID, # invalid storage (meta)data used
}

"Asset representation"
union Asset = AssetUrl | AssetStorage | AssetDeleted

"Asset stored at an external source"
type AssetUrl @variant {
  "The http url pointing to the media"
  url: String!
}

"Asset was deleted and is no longer available."
type AssetDeleted @variant {
  happenedIn: Block!
}

"Storage asset"
type AssetStorage @variant {
  """
  Data object in upload life-cycle.
  If this is deleted, then set oldDataObject in its place if it is set and not rejected, otherwise union goes to Deleted.
  """
  dataObject: AssetDataObject!

  happenedIn: Block!
}

"The decision of the storage provider when it acts as liaison"
enum LiaisonJudgement {
  "Content awaits for a judgment"
  PENDING,

  "Content accepted"
  ACCEPTED,

  "Content rejected"
  REJECTED,
}

"Manages content ids, type and storage provider decision about it"
type AssetDataObject @entity {
  "Content owner"
  owner: AssetOwner!

  "Content added at"
  addedAt: Block!

  "Content type id"
  typeId: Int!

  "Content size in bytes"
  size: BigInt!

  "Storage provider id of the liaison"
  liaisonId: BigInt!

  "Storage provider as liaison judgment"
  liaisonJudgement: LiaisonJudgement!

  "IPFS content id"
  ipfsContentId: String!

  "Joystream runtime content"
  joystreamContentId: String!
}

"Owner type for storage object"
union AssetOwner = AssetOwnerMember | AssetOwnerChannel | AssetOwnerDao | AssetOwnerCouncil | AssetOwnerWorkingGroup

"Asset owned by a member"
type AssetOwnerMember @variant {
  "Member identifier"
  memberId: BigInt!
}

"Asset owned by a channel"
type AssetOwnerChannel @variant {
  "Channel identifier"
  channel: Channel!
}

"Asset owned by a DAO"
type AssetOwnerDao @variant {
  "DAO identifier"
  daoId: BigInt!
}

"Asset owned by the Council"
type AssetOwnerCouncil @variant {
  "Variant needs to have at least one property. This value is not used."
  dummy: Int!
}

"Asset owned by a WorkingGroup"
type AssetOwnerWorkingGroup @variant {
  "Working group identifier"
  workingGroupId: BigInt!
}

#### High Level Derivative Entities ####

type Language @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  "Language identifier ISO 639-1"
  iso: String!

  happenedIn: Block!
}

type Channel @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  # "Owner of the channel" Commenting out this field: 'owner' can be curator_group, lead
  # or a member. We are not handling events related to curator group so we will not set this field
  # owner: Member!

  category: ChannelCategory

  "Reward account where revenue is sent if set."
  rewardAccount: String

  "The title of the Channel"
  title: String @fulltext(query: "search")

  "The description of a Channel"
  description: String

  "Channel's cover (background) photo. Recommended ratio: 16:9."
  coverPhoto: Asset

  "Channel's avatar photo."
  avatarPhoto: Asset

  "Flag signaling whether a channel is public."
  isPublic: Boolean

  "Flag signaling whether a channel is censored."
  isCensored: Boolean!

  "The primary langauge of the channel's content"
  language: Language

  videos: [Video!] @derivedFrom(field: "channel")

  happenedIn: Block!
}

type VideoCategory @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  "The name of the category"
  name: String @fulltext(query: "videoCategoriesByName")

  videos: [Video!] @derivedFrom(field: "category")

  happenedIn: Block!
}

type Video @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  "Reference to member's channel"
  channel: Channel!

  "Reference to a video category"
  category: VideoCategory

  "The title of the video"
  title: String @fulltext(query: "search")

  "The description of the Video"
  description: String

  "Video duration in seconds"
  duration: Int

  "Video thumbnail (recommended ratio: 16:9)"
  thumbnail: Asset

  "Video's main langauge"
  language: Language

  "Whether or not Video contains marketing"
  hasMarketing: Boolean

  "If the Video was published on other platform before beeing published on Joystream - the original publication date"
  publishedBeforeJoystream: DateTime

  "Whether the Video is supposed to be publically displayed"
  isPublic: Boolean

  "Flag signaling whether a video is censored."
  isCensored: Boolean!

  "Whether the Video contains explicit material."
  isExplicit: Boolean

  "License under the video is published"
  license: License

  "Reference to video asset"
  media: Asset

  "Video file metadata"
  mediaMetadata: VideoMediaMetadata

  happenedIn: Block!

  "Is video featured or not"
  isFeatured: Boolean!

  featured: FeaturedVideo @derivedFrom(field: "video")

  # helper properties - redudant info enabling important queries for Joystream use-cases

  is_thumbnail_available: AssetAvailability!
  is_media_available: AssetAvailability!
}

type VideoMediaMetadata @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  "Encoding of the video media object"
  encoding: VideoMediaEncoding

  "Video media width in pixels"
  pixelWidth: Int

  "Video media height in pixels"
  pixelHeight: Int

  "Video media size in bytes"
  size: Int

  video: Video @derivedFrom(field: "mediaMetadata")

  happenedIn: Block!
}

type VideoMediaEncoding @entity {
  "Encoding of the video media object"
  codecName: String

  "Media container format"
  container: String

  "Content MIME type"
  mimeMediaType: String
}

type License @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  "License code defined by Joystream"
  code: Int

  "Attribution (if required by the license)"
  attribution: String

  "Custom license content"
  custom_text: String
}

type FeaturedVideo @entity {
  "Runtime entity identifier (EntityId)"
  id: ID!

  "Reference to a video"
  video: Video!
}
